using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
/*
 * 
 * 
배열이란 같은 종류의 데이터를 연속적으로 저장하는 변수 타입입니다. 
참고로 연속적으로 데이터를 저장한다는 의미는 논리적 개념입니다. 
C++와 비교해서 C#은 Stack 메모리 할당이 없기 때문에 실제 메모리에 연속적으로 저장되지 않습니다.
배열은 일차원만 있는 것이 아니고 다차원 배열도 있습니다.
 - 다차원 배열 선언, 5차의 5개, 즉 배열의 개수는 25개      int[,] a = new int[5, 5];
 - int[][] b = new int[5][];   각 1차원 배열마다 선언되는 배열 수가 다르다.      a[0]는 1개, a[1]는 2개, a[2]는 3개, a[3]는 4개, a[4]는 5개
배열은 단순하게 하나의 변수명에 여러개의 데이터를 저장하는 목적으로 사용하는 것은 아닙니다. 
데이터가 연속적으로 있다고 생각을 하면, 정렬이나 탐색등으로 사용 가능합니다.
정렬이라는 것은 일련의 숫자를 오름차순 혹은 내림차순으로 정리하는 것입니다.


리스트는 선언할 때, 배열처럼 개수를 정하지 않습니다.
즉, 유저가 입력하는 만큼, 계속해서 데이터를 입력할 수 있습니다. 
그러나 리스트에는 치명적인 단점이 있습니다. 리스트라는 것은 연결 리스트 알고리즘으로 구성되어 있습니다. 
즉, 입력은 빠릅니다만, 탐색이 매우 느린 알고리즘 구조입니다.
즉, 대량의 데이터를 사용할 때는 리스트보다 배열의 경우가 탐색 속도가 빠릅니다. 
그러나 사실, 이건 이론적인 이야기입니다. 최근에는 이런 이론적인 이야기를 무시할 만큼, 놀라운 성능의 하드웨어를 사용합니다. 
그래서, 실무에서는 그냥 리스트를 사용합니다. 배열을 사용 함으로 괜히 버그를 만들 필요가 없는 것이지요.
그러나 이것도 엄청난 대량의 데이터(약 1억건 이상의 데이터)라고 한다면 리스트가 아닌 배열을 사용하는 것도 생각해 볼 필요가 있습니다.



ArrayList는 특정 자료형 뿐만 아니라 여러 자료형을 담을 수 있다. 
하지만 List는 선언한 자료형에 맞춰서 데이타를 삽입해야 한다.
ArrayList가 쓰기 편할만큼 데이타를 가져오거나 넣을때 그만큼 느리다. 


ArrayList와 List는 배열과 매우 유사한 컬렉션.
배열과 달리 컬렉션을 생성 시 용량을 미리 지정할 필요가 없음.
필요에 따라 용량이 늘어나거나 줄어 듦.


ArrayList
ArrayList는 선언 시 자료형을 명시하지 않음. 아무 타입이나 들어올 수 있음.

List
List는 선언 시, 특정한 자료형을 명시함. 명시한 자료형만 사용 가능. 나머지는 ArrayList와 동일.



Array 
- 고정된 배열 크기를 갖는다. 선언시 크기를 지정해주고, 삭제및 추가와 같은 변형이 불가능하다.
- 같은 타입만 저장가능하다. (type safe하다)
- 다차원 배열 입력이 가능하다.


ArrayList
- 고정되지 않는, 추가/삭제의 변형이 가능한 객체타입이다.
- 제네릭 타입으로서 서로 다른 타입의 데이터가 배열에 저장가능하다. 때문에 데이터를 가져올때 박싱, 언박싱이 발생하며, type-safe하지 못한 이슈가 있다. 


List 
- 마찬가지로 고정되지 않는 가변 객체 타입이다.
- ArrayList의 단점을 보완하여 컴파일시 배열의 타입추론을 한다. 즉, 같은 타입만 저장가능하고, 때문에 박싱/언박싱이 발생하지않는다.



객체 지향에 대해서 간략하게 다시 설명하면 프로그램을 개발할 때 모든 것을 객체(Object)적으로 생각하여 개발을 하는 것을 의미합니다.
즉, 객체라는 것은 프로그램에서 클래스(Class)의 형태로 관리를 하는 것이고 
또 이 객체를 효과적으로 관리하기 위해서는 리스트(List)와 딕셔너리(Dictionary)를 자주 사용합니다.

리스트는 자료 구조 알고리즘에서는 연결 리스트 알고리즘이고 딕셔너리(Dictionary)는 맵 알고리즘입니다.
연결 리스트의 알고리즘은 처음부터 끝까지의 데이터를 포인터로 연결한 것이고 딕셔너리는 키와 값으로 연결된 자료구조입니다.
리스트에는 0인 값부터 9까지의 Dat를 가진 Node 인스턴스를 순서대로 가지고 있습니다.
리스트는 분명하게 순서가 정해져 있고 5번째의 Node 인스턴스를 가져와서 리스트에서 제거를 했습니다.
그리고 다시 2번째의 리스트에 100의 Data를 가진 Node 인스턴스를 삽입합니다.

이것이 리스트의 특성입니다.

딕셔너리(Dictionary)의 경우는 처음과 끝의 순서가 정해져 있는 것이 아니고 Key가 정해져 있어서 Key로 데이터를 취득해옵니다.
리스트와 다르다는 것은 데이터가 순서대로 있는 것이 아니고 key라는 데이터를 통해서 데이터가 관리되는 것을 확인할 수 있습니다.
참고로 Key의 값은 리스트의 형식으로 순서대로 저장되어 있는 것이 아니라서 Keys로 키의 리스트(?)를 가져올 때 순서대로 가져오지 않는 것을 확인 할 수 있습니다.






*/

namespace book.Concept
{
    internal class Array__list__arraylist
    {
    }
}
